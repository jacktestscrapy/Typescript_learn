{"./":{"url":"./","title":"课程简介","keywords":"","body":"课程简介 ​ 本课程会给读者介绍Typscript的背景, 重点介绍Typscript的特性,比如面向对象、对象、函数、接口以及装饰器等.最后会有一个案例对前面的知识进行实战小结. "},"Introduction/快速入门.html":{"url":"Introduction/快速入门.html","title":"第一章:Typescript快速入门","keywords":"","body":"Typescript快速入门 一、Typescript 是什么 TypeScript 是由微软开发的一款开源的编程语言,是 JavaScript 的⼀个超集，本质上是向这个语⾔添加了可选的静态类型和基于类的⾯向对象编程,因Typescript更像后端Java/C# 这样的面向对象的语言可以让JS开发大型企业项目. TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些⾃ 2015 年开始的 ECMAScript 和未来的提案中的特性，⽐如异步功能和 Decorators，以帮助建⽴健壮的组件。下图显示了 TypeScript 与ES5、ES2015 和 ES2016 之间的关系： 谷歌也在大力支持 Typescript 的推广，谷歌的 angular2.x+就是基于 Typescript 语法;最新的 Vue 、React 也可以集成 TypeScript;Nodejs 框架 Nestjs、midway 中用的就是 TypeScript 语法。 为了直观显示TypeScript和JavaScript的区别,请看下表: TypeScript JavaScript TypeScript用于解决大型项目的代码复杂性 ⼀种脚本语⾔，⽤于创建动态⽹⻚ 强类型，⽀持静态和动态类型 弱类型,没有静态类型选项 最终被编译成 JavaScript 代码，使浏览器可以理解 可以直接在浏览器中使⽤ ⽀持模块、泛型和接⼝ 不⽀持模块、泛型和接⼝ 社区的⽀持仍在增⻓，⽽且还不是很⼤ ⼤量的社区⽀持以及⼤量⽂档和解决问题的支持 二、TypeScript的安装 在终端使用下面命令安装: npm install -g typescript #或者 cnpm install -g typescript #或者 yarn global add typescript 必须先安装nodejs 如果电脑上面没有安装过 cnpm，请先安装 cnpm: npm install -g cnpm --registry=https://registry.npm.taobao.org 如果电脑上面没有安装过 yarn 请先安装 yarn: npm install -g yarn #或者 cnpm install -g yarn 验证TypeScript tsc -v # Version 4.2.2 编译TypeScript文件 tsc hellworld.ts # helloworld.ts => helloworld.js会把ts文件编译成js文件 典型的TypeScript的工作流程 如你所⻅，在上图中包含 3 个 ts ⽂件：a.ts、b.ts 和 c.ts。这些⽂件将被 TypeScript 编译器，根据配置的编译选项编译成 3 个 js ⽂件，即 a.js、b.js 和 c.js。对于⼤多数使⽤ TypeScript 开发的 Web 项⽬，我们还会对编译⽣成的 js ⽂件进⾏打包处理，然后在进⾏部署。 三、TypeScript初体验 一下仅仅做演示.新建一个helloworld.ts文件并输入一下内容 function greet(person: string) { return 'Hello, ' + person; } console.log(greet(\"TypeScript\")); 然后执行tsc helloworld.ts命令, 之后会生成一个编译后的helloworld.js文件. function greet(person) { return 'Hello, ' + person; } console.log(greet(\"TypeScript\")); 观察以上编译后的输出结果，我们发现 person 参数的类型信息在编译后被擦除了。TypeScript 只会在编译阶段对类型进⾏静态检查，如果发现有错误，编译时就会报错。⽽在运⾏时，编译⽣成的 JS 与普通的 JavaScript ⽂件⼀样，并不会进⾏类型检查。 四、自动编译ts文件 方法一: 直接在终端执行命令: tsc -w 进行监控, 监控tsc 是否改变,改变后直接进行编译,生成对应的js 文件. tsc -w 命令中w 是watch 监听监视的意思. 监听文件是否修改. tsc helloworld.ts -w 监听指定文件. 方法二: 在vscode工具的终端下执行:tsc --init 自动生成tsconfig.json文件,然后修改配置文件,如下 然后在vscode 点击: 终端->运行任务->typescript-> tsc:监视-tsconfig.json 然后就可以自动生成代码了. 关于tsconfig.json的内容在下一章节进行详解. "},"Introduction/tsconfig.html":{"url":"Introduction/tsconfig.html","title":"1.Tsconfig详解","keywords":"","body":"Tsconfig.json详解 一、为什么使用tsconfig.json 通常我们可以使用 tsc 命令来编译少量 TypeScript 文件,但如果实际开发的项目，很少是只有单个文件，当我们需要编译整个项目时，就可以使用 tsconfig.json 文件，将需要使用到的配置都写进 tsconfig.json 文件，这样就不用每次编译都手动输入配置，另外也方便团队协作开发. 二、什么是tsconfig.json TypeScript 使用 tsconfig.json 文件作为其配置文件，当一个目录中存在 tsconfig.json 文件，则认为该目录为 TypeScript 项目的根目录。通常 tsconfig.json 文件主要包含两部分内容：指定待编译文件和定义编译选项。待编译文件主要通过files、include、exclude进行控制. tsconfig.json 文件有以下几个顶层属性： 名称 作用 compileOnSave 设置保存文件的时候自动编译，但需要编译器支持 compilerOptions 配置编译选项. 此项非常重要. exclude 指定编译器需要排除的文件或文件夹 extends 引入其他配置文件，继承配置。 files 指定需要编译的单个文件列表 include 指定编译需要编译的文件或目录。 references 指定工程引用依赖 typeAcquisition 设置自动引入库类型定义文件(.d.ts)相关 注意: 如不设定 files 和 include，ts 默认是 exclude 以外的所有的以 .ts 和 .tsx 结尾的文件。如果，同时设置 files 的优先级最高，exclude 次之，include 最低。 三、配置介绍 1.compileOnSave compileOnSave如果设为true,在我们编辑了项目文件保存的时候，编辑器会根据tsconfig.json的配置更新重新生成文本，不过这个编辑器支持 // tsconfig.json { \"compileOnSave\": true/false } 2. exclude exclude表示要排除的、不编译的文件，它也可以指定一个列表，可以是文件或文件夹，可以是相对路径或绝对路径，可以使用通配符. 支持的通配符: *匹配0或多个任意字符 ?匹配一个任意字符 **/递归匹配任意子目录 { \"exclude\": [ \"src/lib\", // 排除src目录下的lib文件夹下的文件不会编译 \"src/**/*\" // 匹配src目录下的任意子目录中的任意文件 ] } 3.extends extends可以通过指定一个其他的tsconfig.json文件路径，来继承这个配置文件里的配置，继承来的文件的配置会覆盖当前文件定义的配置.TS在3.2版本开始，支持继承一个来自Node.js包的tsconfig.json配置文件. { // 把基础配置抽离成tsconfig.base.json文件,然后引入 \"extends\": \"./tsconfig.base.json\" } 4. files files可以配置一个数组列表，里面包含指定文件的相对或绝对路径，编译器在编译的时候只会编译包含在files中列出的文件，如果不指定，则取决于有没有设置include选项，如果没有include选项，则默认会编译根目录以及所有子目录中的文件。这里列出的路径必须是指定文件，而不是某个文件夹，而且不能使用 ? */ 等通配符. { \"files\": [ //指定编译文件是src目录下的helloworld.ts文件 \"src/helloworld.ts\" ] } 5. include include也可以指定要编译的路径列表，但是和files的区别在于，这里的路径可以是文件夹，也可以是文件，可以使用相对和绝对路径，而且可以使用通配符. { \"include\":[ // 编译src 目录下的所有文件,包括子目录 \"src\", // 只会编译src目录下的一级子目录 \"src/*\", // 编译src 目录下的一级子目录下的文件 \"src/*/*\" ] } 6. references References 一个对象数组，指定要引用的项目. 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包,那么我们可以进行如下配置 { \"references\":[ //指定依赖的工程 {\"path\": \"./common\"} ] } 7. typeAcquisition typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关.包含 3 个子属性： enable : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false； include : 数组类型，允许自动引入的库名，如：[\"jquery\", \"lodash\"]； exculde : 数组类型，排除的库名。 { \"typeAcquistion\":{ // 不开启自动引入库类型 \"enable\": false, // 允许自动引入的库 \"include\": [\"jquery\",\"lodash\"], // 排除的库 \"exclude\": [\"jest\",\"koa\"] } } 8. compilerOptions compilerOptions配置编译相关的选项.若 compilerOptions 属性被忽略，则编译器会使用默认值. { \"compilerOptions\": { /* 基础选项 */ \"target\": \"es5\" /* target用于指定编译之后的版本目标: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */, \"module\": \"commonjs\" /* 用来指定要使用的模块标准: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */, \"lib\": [\"es6\", \"dom\"] /* lib用于指定要包含在编译中的库文件 */, \"allowJs\": true, /* allowJs设置的值为true或false，用来指定是否允许编译js文件，默认是false，即不编译js文件 */ \"checkJs\": true, /* checkJs的值为true或false，用来指定是否检查和报告js文件中的错误，默认是false */ \"jsx\": \"preserve\", /* 指定jsx代码用于的开发环境: 'preserve', 'react-native', or 'react'. */ \"declaration\": true, /* declaration的值为true或false，用来指定是否在编译的时候生成相应的\".d.ts\"声明文件。如果设为true，编译每个ts文件之后会生成一个js文件和一个声明文件。但是declaration和allowJs不能同时设为true */ \"declarationMap\": true, /* 值为true或false，指定是否为声明文件.d.ts生成map文件 */ \"sourceMap\": true, /* sourceMap的值为true或false，用来指定编译时是否生成.map文件 */ \"outFile\": \"./\", /* outFile用于指定将输出文件合并为一个文件，它的值为一个文件路径名。比如设置为\"./dist/main.js\"，则输出的文件为一个main.js文件。但是要注意，只有设置module的值为amd和system模块时才支持这个配置 */ \"outDir\": \"./\", /* outDir用来指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹 */ \"rootDir\": \"./\", /* 用来指定编译文件的根目录，编译器会在根目录查找入口文件，如果编译器发现以rootDir的值作为根目录查找入口文件并不会把所有文件加载进去的话会报错，但是不会停止编译 */ \"composite\": true, /* 是否编译构建引用项目 */ \"incremental\": true, /* 是否启用增量编译*/ \"tsBuildInfoFile\": \"./\", /* 指定文件用来存储增量编译信息 */ \"removeComments\": true, /* removeComments的值为true或false，用于指定是否将编译后的文件中的注释删掉，设为true的话即删掉注释，默认为false */ \"noEmit\": true, /* 不生成编译文件，这个一般比较少用 */ \"importHelpers\": true, /* importHelpers的值为true或false，指定是否引入tslib里的辅助工具函数，默认为false */ \"downlevelIteration\": true, /* 当target为'ES5' or 'ES3'时，为'for-of', spread, and destructuring'中的迭代器提供完全支持 */ \"isolatedModules\": true, /* isolatedModules的值为true或false，指定是否将每个文件作为单独的模块，默认为true，它不可以和declaration同时设定 */ /* 严格类型检查选项 */ \"strict\": true /* strict的值为true或false，用于指定是否启动所有类型检查，如果设为true则会同时开启下面这几个严格类型检查，默认为false */, \"noImplicitAny\": true, /* noImplicitAny的值为true或false，如果我们没有为一些值设置明确的类型，编译器会默认认为这个值为any，如果noImplicitAny的值为true的话,则没有明确的类型会报错。默认值为false */ \"strictNullChecks\": true, /* strictNullChecks为true时，null和undefined值不能赋给非这两种类型的值，别的类型也不能赋给他们，除了any类型。还有个例外就是undefined可以赋值给void类型 */ \"strictFunctionTypes\": true, /* strictFunctionTypes的值为true或false，用于指定是否使用函数参数双向协变检查 */ \"strictBindCallApply\": true, /* 设为true后会对bind、call和apply绑定的方法的参数的检测是严格检测的 */ \"strictPropertyInitialization\": true, /* 设为true后会检查类的非undefined属性是否已经在构造函数里初始化，如果要开启这项，需要同时开启strictNullChecks，默认为false */ \"noImplicitThis\": true, /* 当this表达式的值为any类型的时候，生成一个错误 */ \"alwaysStrict\": true, /* alwaysStrict的值为true或false，指定始终以严格模式检查每个模块，并且在编译之后的js文件中加入\"use strict\"字符串，用来告诉浏览器该js为严格模式 */ /* 额外的检查 */ \"noUnusedLocals\": true, /* 用于检查是否有定义了但是没有使用的变量，对于这一点的检测，使用eslint可以在你书写代码的时候做提示，你可以配合使用。它的默认值为false */ \"noUnusedParameters\": true, /* 用于检查是否有在函数体中没有使用的参数，这个也可以配合eslint来做检查，默认为false */ \"noImplicitReturns\": true, /* 用于检查函数是否有返回值，设为true后，如果函数没有返回值则会提示，默认为false */ \"noFallthroughCasesInSwitch\": true, /* 用于检查switch中是否有case没有使用break跳出switch，默认为false */ /* 模块解析选项 */ \"moduleResolution\": \"node\", /* 用于选择模块解析策略，有'node'和'classic'两种类型' */ \"baseUrl\": \"./\", /* baseUrl用于设置解析非相对模块名称的基本目录，相对模块不会受baseUrl的影响 */ \"paths\": {}, /* 用于设置模块名称到基于baseUrl的路径映射 */ \"rootDirs\": [], /* rootDirs可以指定一个路径列表，在构建时编译器会将这个路径列表中的路径的内容都放到一个文件夹中 */ \"typeRoots\": [], /* typeRoots用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载 */ \"types\": [], /* types用来指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来 */ \"allowSyntheticDefaultImports\": true, /* 用来指定允许从没有默认导出的模块中默认导入 */ \"esModuleInterop\": true /* 通过为导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性 */, \"preserveSymlinks\": true, /* 不把符号链接解析为其真实路径，具体可以了解下webpack和nodejs的symlink相关知识 */ /* Source Map Options */ \"sourceRoot\": \"\", /* sourceRoot用于指定调试器应该找到TypeScript文件而不是源文件位置，这个值会被写进.map文件里 */ \"mapRoot\": \"\", /* mapRoot用于指定调试器找到映射文件而非生成文件的位置，指定map文件的根路径，该选项会影响.map文件中的sources属性 */ \"inlineSourceMap\": true, /* 指定是否将map文件的内容和js文件编译在同一个js文件中，如果设为true，则map的内容会以//# sourceMappingURL=然后拼接base64字符串的形式插入在js文件底部 */ \"inlineSources\": true, /* 用于指定是否进一步将.ts文件的内容也包含到输入文件中 */ /* 其他选项 */ \"experimentalDecorators\": true /* 用于指定是否启用实验性的装饰器特性 */ \"emitDecoratorMetadata\": true, /* 用于指定是否为装饰器提供元数据支持，关于元数据，也是ES6的新标准，可以通过Reflect提供的静态方法获取元数据，如果需要使用Reflect的一些方法，需要引入ES2015.Reflect这个库 */ } } 四、常见配置示例 Tsconfig.json示例. { \"include\": [\"src/**/*\"], \"exclude\": [\"no_modules\"], \"compilerOptions\":{ \"target\": \"es2015\", /* 指定编译后的版本*/ \"module\": \"ESNext\", /* 用来指定要使用的模块标准*/ \"noEmitOnError\": true, /*编译的源文件中存在错误的时候不再输出编译结果文件*/ //\"lib\":[], /*用于指定要包含在编译中的库文件*/ \"allowJS\": false, \"outDir\": \"src\", \"rootDir\": \"./\", \"removeComments\":true, \"importHelpers\":true, \"strict\":true, \"noImplicitAny\": true, \"strictNullChecks\": true, \"noImplicitThis\": true, \"baseUrl\": \"./\", \"paths\": {}, \"experimentalDecorators\": true, \"emitDecoratorMetadata\": true } } "},"Introduction/webpack&ts.html":{"url":"Introduction/webpack&ts.html","title":" 2.Webpack打包ts代码","keywords":"","body":"Webpack打包ts文件 一、初步打包项目 在终端下执行命令: npm init -y创建package.json管理项目.然后安装webpack 集成ts的依赖: npm install -D webpack webpack-cli typescript ts-loader 安装完成后会在package.json的开发依赖下自动添加进去刚才安装的依赖. 然后再项目根目录下创建webpack.config.js文件,对webpack进行配置 const path = require('path'); module.exports = { // 配置模式 mode: 'development', // 开发模式模式, production 生产模式 // 配置入口目录 entry: \"./src/helloworld.ts\", // 配置输出 output: { // 配置多出口文件生成 filename: '[name].js', // 输出的js path: path.resolve(__dirname, 'dist') // 需要导入node的path模块,最终生成的目录在dist }, // 配置load ,让webpack处理费js的资源如:css img 等等 module: { // 指定加载规则 rules: [ { test: /\\.ts$/, use: 'ts-loader', exclude: /node_modules/ } ] }, // 配置要引用的模块 resolve:{ extensions:['.ts', '.tsx', 'js'] } // 配置插件 plugins: [] } 然后在package.json中添加打包命令,然后就可以在终端下执行: npm run build 进行打包,会在dist目录下生成打包后的文件. 二、使用WebPack相关插件打包项目 1. Html-webpack-plugin Html-webpack-plugin能够让我们使用模板创建页面,避免重复的手工创建. 终端下执行命令进行安装: npm install -D html-webpack-plugin 安装后在webpack.config.js 中进行引用, 并在src 目录下创建模板index.html 2. Webpack-dev-server和clean-webpack-plugin Webpack-dev-server能检测网页是否有改动, 改动就自动刷新; clean-webpack-plugin是自动清除打包后的旧文件,保证打包后的文件时最新的 在终端下执行命令安装页面热加载服务器, npm i -D webpack-dev-server clean-webpack-plugin 安装完毕后在package.json 文件下添加启动服务的命令, 然后在终端下执行: npm start 自动打开打包后的网页 # MAC \"start\": \"webpack serve --open 'google chrome'\" # Window \"start\": \"webpack serve --open chrome.exe\" 修改webpack.config.js 文件,引入并使用clean-webpack-plugin. 3. 使用babel 解决兼容 在终端下执行下面命令进行安装相关依赖: npm install -D @babel/core @babel/preset-env babel-loader core-js 安装后修改webpack.config.js,修改后如下: const path = require('path'); // 引入 const HTMLWebPackPlugin = require('html-webpack-plugin') const { CleanWebpackPlugin } = require('clean-webpack-plugin') module.exports = { // 配置模式 mode: 'development', // 开发模式模式, production 生产模式 // 配置入口目录 entry: \"./src/helloworld.ts\", // 配置输出 output: { // 配置多出口文件生成 filename: '[name].js', // 输出的js path: path.resolve(__dirname, 'dist'), // 需要导入node的path模块,最终生成的目录在dist // 告诉webpack 不适用箭头函数 environment:{ arrowFunction: false } }, // 配置load ,让webpack处理费js的资源如:css img 等等 module: { // 指定加载规则 rules: [ { test: /\\.ts$/, use: [ // 配置babel,按需配置 { // 配置加载器 loader: \"babel-loader\", // 配置babel options: { // 设置预定义环境 presets: [ [ // 指定环境插件 \"@babel/preset-env\", // 配置信息 { // 配置项目要兼容的浏览器版本 targets: { \"chrome\": \"88\", 'is':\"11\" }, // 版本要和下载的大版本一致 \"corejs\": \"3\", // 使用corejs的方式是: 按需加载 \"useBuiltIns\": \"usage\" } ] ] } }, 'ts-loader' ], exclude: /node_modules/ } ] }, resolve: { extensions:['.ts', '.tsx', '.js'] }, // 配置插件 plugins: [ new CleanWebpackPlugin(), // 创建htmlwebpackplugin对象 new HTMLWebPackPlugin({ // z指定标题 title: \"自定义标题\", // 指定模板 template: \"./src/index.html\" }) ] } 自此我们的前期准备全部完成. "},"BasicTypes/basetype.html":{"url":"BasicTypes/basetype.html","title":"第二章: 基础类型","keywords":"","body":"基础类型 一、Boolean、 Number、String、Symbol 1. Boolean 类型 let flag: boolean = false; // flag=1 错误 2. Number 类型 let count:number = 20; console.log(count = 12.3) 3. String 类型 let name:string = \"Panda\" 4. Symbol类型 Symbol 是不可变的唯一的. 使用Symbol 构造函数创建. // 使用Symbol进行构造 let sym1 = Symbol() // 不可变唯一 let sym2 = Symbol('key') let sym3 = Symbol('key') // 返回false console.log(sym2 === sym3) 二、Array、 Tuple、enum 1. Array 类型 第一种定义方式: let list: nunber[] = [1,2,3] 第二种定义方式: let list: Array = [1,2,3] 2. Tuple 类型 众所周知，数组⼀般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使⽤元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其⼯作⽅式类似于数组。 元组可⽤于定义具有有限数量的未命名属性的类型。每个属性都有⼀个关联的类型。使⽤元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看⼀个具体的例⼦： let tupleType: [string, boolean]; tupleType = [\"panda\", true]; 在上⾯代码中，我们定义了⼀个名为 tupleType 的变量，它的类型是⼀个类型数组 [string,boolean] ，然后我们按照正确的类型依次初始化 tupleType 变量。与数组⼀样，我们可以通过下标来访问元组中的元素： console.log(tupleType[0]); // panda console.log(tupleType[1]); // true 在元组初始化的时候，如果出现类型不匹配的话，⽐如： tupleType = [true, \"panda\"]; 此时，TypeScript 编译器会提示以下错误信息： [0]: Type 'true' is not assignable to type 'string'. [1]: Type 'string' is not assignable to type 'boolean'. 很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误，⽐如： tupleType = [\"panda\"]; 此时，TypeScript 编译器会提示以下错误信息： Property '1' is missing in type '[string]' but required in type '[string,boolean]'. 3. Enum 类型 使⽤枚举我们可以定义⼀些带名字的常量。 使⽤枚举可以清晰地表达意图或创建⼀组有区别的⽤例.TypeScript ⽀持数字的和基于字符串的枚举。 1. 数字枚举 enum Names{ panda, alex, queen, king } let first_name: Names = Names.panda console.log(first_name) // 输出0 默认情况下，panda 的初始值为 0，其余的成员会从 1 开始⾃动增⻓。也可以设置初始值. enum Names{ panda=3, alex, queen, king } // 默认输出枚举成员的值 let first_name: Names = Names.panda // 可以根据值获取枚举成员 let sec_name: string = Names[4] console.log(first_name) console.log(sec_name) 2. 字符串枚举 在⼀个字符串枚举⾥，每个成员都必须⽤字符串字⾯量，或另外⼀个字符串枚举成员进⾏初始化。 enum Names{ panda=\"Panda\", alex=\"Alex\", queen=\"Queen\", king=\"King\" } // 默认输出枚举成员的值, 两种效果一样 let first_name = Names.panda let sec_name = Names['panda'] console.log(first_name) console.log(sec_name) 3. 常量枚举 除了数字枚举和字符串枚举之外，还有⼀种特殊的枚举 —— 常量枚举。它是使⽤ const 关键字修饰的枚举，常量枚举在编译阶段不会参与编译,会被移除.当我们需要的是常量的值而不是对象时可以使用常量枚举,这样可以节省编译时间.例如: const enum Names{ panda, alex, queen, king } let first_name = Names.panda console.log(first_name) // 输出0 三、Any、Unknown 1. Any 类型 表示任意类型, 变量类型设置为any 相当于关闭了TS的类型检查. 所以在使用TS 时,不建议使用any 类型. let notSure: any notSure = 666 notSure = \"hello\" TypeScript 允许我们对 any 类型的值执⾏任何操作，⽽⽆需事先执⾏任何形式的检查.在许多场景下，这太宽松了。使⽤ any 类型，可以很容易地编写类型正确但在运⾏时有问题的代码。如果我们使⽤ any 类型，就⽆法使⽤ TypeScript 提供的⼤量的保护机制。为了解决 any 带来的问题，引入unknown 2. unKnown 类型 unknown 类型只能被赋值给 any 类型和 unknown 类型本身。直观地说：只有能够保存任意类型值的容器才能保存 unknown 类型的值。 let value: unknown; value = true; value = 42; value = \"hello world\" value = [] // unknown 只能赋值给any 类型或者unknown let value1: unknown = value; let value2: any = value; // 会爬出错误:不能把类型unknown 分配给类型number // let value3: number = value; 四、Void Null Undefined 1. Void 某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型.当⼀个函数没有返回值时,可以设置返回值类型是void. function sum(): void{ console.log('警告信息') } console.log(sum()) // 返回 警告信息和undefined 需要注意的是，声明⼀个 void 类型的变量没有什么作⽤，因为在严格模式下，它的值只能为undefined ： 2. Null 和Undefined undefined 和 null 两者有各⾃的类型分别为 undefined 和 null 。当使用严格模式,null和undefined 只能分配给unknown和any类型使用. 若给一个变量传递多个类型可以使用联合类型. let u: undefined = undefined; let n: null = null; let d: string | number | undefined 五、Never、Object、Function 1. Never never 类型表示的是值不会存在的类型。例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型 // 返回never的函数必须存在⽆法达到的终点 function error(message: string): never { throw new Error(message); } // 死循环无返回值 function infiniteLoop(): never { while (true) {} } 2.Object let obj: object = { x: 1, y: 2 } // 会抛出object不存在属性x //obj.x = 4 let obj1: { x: number, y: number } = { x: 1, y: 2 } obj1.x = 3 3.Function 使用函数类型,可以先声明函数以及函数的返回值类型,或者函数中参数类型,可以直接调用不用重复声明. // 定义函数类型 let computer: (x: number, y: number) => number // 定义函数 computer = (a,b)=> a+b 六、联合类型、类型断言、类型推断 1.联合类型 联合类型（Union Types）表示取值可以为多种类型中的一种.例如, 注册网站时名字可以是字符串,也可以是手机号.此时就可以使用联合类型 let names: string | Object | number names = \"panda\" names = { \"name\": 12, \"age\": \"13\" } names = 1761234678 2. 类型断言 类型断言和其他语言的类型转换相似, 但是不进行特殊的数据检查和解构.它只在编译阶段起作用,没有运行时影响. 类型断言两种方式,效果一样: 尖括号语法 let someValue: any = \"this is a string\"; let strLength: number = (someValue).length; as 语法 let someValue: any = \"this is a string\"; let strLength: number = (someValue as string).length; 3. 类型推断 类型推断: TS会在没有明确的指定类型的时候推测出一个类型. 有下面2种情况: 1. 定义变量时赋值了, 推断为对应的类型. 2. 定义变量时没有赋值, 推断为any类型 /* 定义变量时赋值了, 推断为对应的类型 */ let b9 = 123 // number // b9 = 'abc' // error /* 定义变量时没有赋值, 推断为any类型 */ let b10 // any类型 b10 = 123 b10 = 'abc' "},"function.html":{"url":"function.html","title":"第三章: 函数","keywords":"","body":"函数 一、定义函数 和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。 // 命名函数 function fullName(x: number, y: nunber): { return x+y } console.log(fullName(123, 123)) // 246 // 匿名函数 let myName = function (x: number, y: string) { return x+y } console.log(myName(12,'12')) // 1212 二、可选参数和默认参数和剩余参数 在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的是undefined时,我们可以使用默认值. function buildName(firstName: string='panda', lastName?: string): string { if (lastName) { return firstName + '-' + lastName } else { return firstName } } 默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来.此时我们可以使用剩余参数, 它可以接收0个或者任意个参数. // 剩余参数 接受新参传过来的任意多个值 function count(...result:number[]) { var sum = 0; for (var i = 0; i 三、函数重载 函数重载: 函数名相同, 而形参不同的多个函数.在JS中, 由于弱类型的特点和形参与实参可以不匹配, 是没有函数重载这一说的 但在TS中, 与其它面向对象的语言(如Java)就存在此语法. //函数重载 function add (x: string, y: string): string function add (x: number, y: number): number // 定义函数实现 function add(x: string | number, y: string | number): string | number { // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y if (typeof x === 'string' && typeof y === 'string') { return x + y } else if (typeof x === 'number' && typeof y === 'number') { return x + y } } console.log(add(1, 2)) console.log(add('a', 'b')) // console.log(add(1, 'a')) // error "},"Classes/class.html":{"url":"Classes/class.html","title":"第四章: 类","keywords":"","body":"类的属性和方法 在⾯向对象语⾔中，类是⼀种⾯向对象计算机编程语⾔的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和⽅法. 在 TypeScript 中，我们可以通过 Class 关键字来定义⼀个类.类中的属性和方法分为静态属性、对象属性、静态方法、对象方法. 静态方法和静态属性,使用类进行调用, 静态属性的值可以修改; 对象方法和对象属性使用类对象进行调用. 构造函数在创建类对象时优先初始化 class Greeter { // 静态属性 static cname: string = \"King\"; // 成员属性 greeting: string=\"Panda\"; // 构造函数 - 执⾏初始化操作 constructor(message: string) { console.log(\"我优先执行!!\") this.greeting = message; } // 静态⽅法 static getClassName() { return \"Class name is Greeter\"; } // 成员⽅法 greet() { return \"Hello, \" + this.greeting; } } let greeter = new Greeter(\"world\"); // 调用静态属性 // greeter.cname 静态属性不能通过类对象进行调用 greeter.greeting // 成员属性可以使用对象调用 console.log(Greeter.cname) // 静态属性使用类调用 // 修改静态属性的值和成员属性的值 Greeter.cname = \"panda\" greeter.greeting = \"king\" console.log(Greeter.cname, greeter.greeting) // 调用实例方法 console.log(greeter.greet()) // 调用静态方法 console.log(Greeter.getClassName()) "},"Classes/inheritance.html":{"url":"Classes/inheritance.html","title":"1. 继承","keywords":"","body":"继承 一、继承初识 在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。 继承（Inheritance）是⼀种联结类与类的层次模型。指的是⼀个类（称为⼦类、⼦接⼝）继承另外的⼀个类（称为⽗类、⽗接⼝）的功能，并可以增加它⾃⼰的新功能的能⼒，继承是类与类或者接⼝与接⼝之间最常⻅的关系。继承是一种is-a关系: 在 TypeScript 中，可以使用extentds关键字实现继承. // 定义基类 class Animal{ name: string; run(distance: number) { return `Animal 能跑${distance}米远` } } // 定义子类 class Dog extends Animal{ eat(something:string ) { return `Dog 能吃${something}` } } const dog = new Dog() console.log(dog.run(30)) console.log(dog.eat('骨头')) 在这例子中我们能看出Dog继承了Animal的方法.所以在dog对象中能调用基类的run()方法. 二、super 上面我们使用extends实现了基本的继承,但是当我们要继承父类的构造方法或者重写父类的方法来扩展子类的功能时,我们必须使用super. class Animal{ // 定义属性 name: string; // 构造函数 constructor(n: string) { this.name = n } run(distance: number) { console.log(`${this.name} 跑 ${distance}m`) } } class Dog extends Animal{ name:string='藏獒' constructor(name: string) { // 调用基类的构造方法, super()必须在构造函数中第一个实现,否则报错. super(name) // 输出 console.log(`${this.name}`) } // 重写父类的方法 run(distance: number = 5) { super.run(distance) console.log(`子类dog的run方法: ${this.name} 跑了 ${distance}`) } eat(something:string ) { return `Dog 能吃${something}` } } const dog = new Dog('京巴') dog.run() const dog1:Animal = new Dog('中华田园犬') dog1.run(34) 子类通过super()调用父类的方法,会执行基类的构造方法, 执行完后才会继续执行自己的构造方法., 如果子类中定义自己的属性, 会 三、子类使用父类的属性和方法 若子类定义自己的属性, 默认使用子类的属性, 若不定义自己的属性, 使用基类的属性. class Animal{ // 定义属性 name: string; // 构造函数 constructor(n: string) { this.name = n } run(distance: number) { console.log(`${this.name} 跑 ${distance}m`) } } class Dog extends Animal{ name: string=\"king\" constructor(name: string) { // 调用基类的构造方法 super(name) console.log(`${name}`) // this.name = name console.log(`${this.name}`) } // 重写父类的方法 run(distance: number = 5) { super.run(distance) console.log(`子类dog的run方法: ${this.name} 跑了 ${distance}`) } eat(something:string ) { return `Dog 能吃${something}` } } class QiuDog extends Dog{ // 默认使用子类的属性.若注释掉就使用父类的属性值 name: string = '秋田犬' constructor(n: string) { // 调用基类构造方法 super(n) // 给属性赋值,会使用传递的二狗子 // this.name = n } cry() { console.log(`${this.name} 能旺旺叫`) } } const qiudog = new QiuDog('二狗子') qiudog.cry() console.log(qiudog.name) "},"Classes/modifiers.html":{"url":"Classes/modifiers.html","title":"2.常用修饰符","keywords":"","body":"常用修饰符 一、Public、Private、Protected 在TypeScript里,public、private、protected修饰符是用来描述类内部的属性或者方法的可访问性. 成员都默认为public, 可也以明确将一个成员标记为public,它代表公开的, 类内部或外部都可以访问. private表示只能在类内部访问, 当成员被标记为private时,它就不能在声明它的类外部访问 protected表示类内部和子类可以访问. class Animal{ // 定义属性, 默认是public public name: string; // 构造函数,默认是public public constructor(n: string) { this.name = n } public run(distance: number) { console.log(`${this.name} 跑 ${distance}m`) } } class Dog extends Animal{ // 定义私有属性, 只能类内部访问 private age: number = 18 // 定义受保护对象, 在类内部以及子类中访问 protected sex: string = '男' // 重写父类的方法 run(distance: number = 5) { super.run(distance) console.log('子类Dog的run方法') } } class QiuDog extends Dog{ run(distance: number = 6) { super.run(distance) console.log(this.sex) // 子类能看到父类中受保护的成员 // console.log(this.age) // age 为私有属性,不能在子类中访问 } } console.log(new Dog('牧羊').name) // 牧羊. name 是公有属性,可以 console.log(new QiuDog('牧羊').run()) // 子类可以访问protected的属性. // console.log(new QiuDog('牧羊').sex) // 受保护的不能在类外访问,只能在类里访问 // console.log(new Dog('牧羊').age) // 私有属性只能在类内部访问 二、readonly和参数属性 可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 class Person { readonly name: string = 'panda' constructor(name: string) { this.name = name } } let john = new Person('king') // john.name = 'peter' // error name 是只读的不能修改 我们必须在 Person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到.参数属性可以方便地让我们在一个地方定义并初始化一个成员。 class Person { private readonly age:number = 8; constructor(readonly name: string) { this.name = name } } let p = new Person('king') // p.name = \"hah\" // 只读属性不能修改 // p.age //私有属性只能在类内部访问 三、存取器 TypeScript 支持通过 getters/setters 来截取对对象成员的访问.我们可以通过 getters 和 setters ⽅法来实现数据的封装和有效性校验，防⽌出现 异常数据。 const nameLength = 16; class UserInfo { private _userName:string = \"panda_kings\" // 获取用户名 get userName(): string { return this._userName; } // 设置用户名 set userName(newName: string) { if (newName.length > nameLength) { console.log(\"用户名的最大长度为\" + nameLength) throw new Error(\"用户名的最大长度为 \" + nameLength); } this._userName = newName; } } let userInfo = new UserInfo(); // 获取名字,默认会调用get userName方法 console.log(userInfo.userName) // panda_kings // 设置名字,默认会调用set userName方法 userInfo.userName = \"panda1234567890-asdas\" "},"Classes/abstract.html":{"url":"Classes/abstract.html","title":"3.抽象类和类方法重载","keywords":"","body":"抽象类和类方法重载 一、抽象类 使⽤ abstract 关键字声明的类，我们称之为抽象类。抽象类做为其它派生类的基类使用,抽象类不能被实例化，因为它⾥⾯包含⼀个或多个抽象⽅法。所谓的抽象⽅法，是指不包含具体实现的⽅法. 使用原则: 抽象类不能被实例化, 只能继承使用 抽象类中的抽象方法,在派生类中要全部实现,否则报错. 抽象方法可当做类的实例方法，添加访问修饰符 abstract class Person { constructor(public name: string){} // 抽象⽅法, 抽象方法必须在派生类中实现 abstract say(words: string) :void; } class Developer extends Person { constructor(name: string) { super(name); } say(words: string): void { console.log(`${this.name} says ${words}`); } } const lolo = new Developer(\"lolo\"); lolo.say(\"I love ts!\"); // lolo says I love ts! 二、类方法重载 类方法重载和函数的重载一样.在下面例子中我们重载了getProducts方法. class ProductService { getProducts(): void; getProducts(id: number): void; getProducts(id?: number) { if(typeof id === 'number') { console.log(`获取id为 ${id} 的产品信息`); } else { console.log(`获取所有的产品信息`); } } } const productService = new ProductService(); productService.getProducts(666); // 获取id为 666 的产品信息 productService.getProducts(); // 获取所有的产品信息 "},"interface.html":{"url":"interface.html","title":"第五章:接口","keywords":"","body":"接口 一、接口初识 接口的作用：在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范，在程序设计里面，接口起到一种限制和规范的作用。 接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，它只规定这批类里必须提供某些方法，提供这些方法的类就可以满足实际需要。 1. 定义接口 接口是对象状态(属性)和行为(方法)的抽象描述. Typescript的核心原则之一,是对值所具有的结构进行类型检查, 我们可以定义接口(Interfaces)来定义对象类型. /* 需求: 创建人的对象, 需要对人的属性进行一定的约束 id是number类型, 必须有, 只读的 name是string类型, 必须有 age是number类型, 必须有 sex是string类型, 可以没有 */ // 定义人的接口 interface IPerson { id: number name: string age: number sex: string } const person1: IPerson = { id: 1, name: 'tom', age: 20, sex: '男' } 类型检查器会查看对象内部的属性是否与IPerson接口描述一致, 如果不一致就会提示类型错误 2.可选属性和只读属性 上面需求中的sex 属性是可选的, 不是必须的. 我们可以在定义时在可选属性后面添加“?”符号. 可选属性的哈出就是对可能存在的属性进行预定义, 可以捕获引用了不存在属性时的错误. interface IPerson { id: number name: string age: number sex?: string // 定义可选属性 } const person1: IPerson = { id: 1, name: \"Tom\", age: 20, sex: '男' } const person2: IPerson = { id: 1, name: \"Tom\", age: 20, //sex: 'female'// 可以没有 } 只读属性,就是只能在对象刚刚创建的时候修改,不能在使用过程中修改. 可以使用readonly来指定. interface IPerson { readonly id: number name: string age: number sex?: string } const person:IPerson{ id:1, name: \"panda\", age:30 } person.id = 2 // error 3. 任意属性 有时候我们希望⼀个接⼝中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使⽤ 索引签名 或者传递对象的形式来满⾜上述要求。 interface IPerson { name: string; age?: number; // 定义索引签名 [argName: string]:any } function UserInfo(info: IPerson):{name:string, age: number} { return { name: info.name, age: info.age } } /* * 第一种方式使用索引签名, 可以传入任意的类型的属性 */ let userInfo = UserInfo({ name: 'panda', age: 31, sex:'男', height: 220 }) /* *传入对象方式,接口不会进行过多的属性检查,只会检查传入的对象中是否有传入的属性. * 此方法不建议使用. let user = { name: 'panda', age: 31, sex: '男', height: 220 } let userInfo = UserInfo(user) */ 二、接口实现函数类型 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它是对参数和返回值类型的约束。参数列表里的每个参数都需要名字和类型。 // 定义接口 interface IAdd{ // 函数的参数a和b以及返回类型 (a: number, b: number): number } 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口.下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 // add为函数类型的变量,冒号后面是函数的实现. let add: IAdd: (a,b)=> a + b console.log(add(10, 20)) // 返回30 三、类类型接口 我们可以定义类类型接口,然后在实现类,能够对类进行批量约束, 和抽象类相似. 注意: 接口只能约束类的公有成员, 构造函数、私有成员和受保护成员不能被约束. interface Animal{ name: string; run(distance:number): void; } class Dog implements Animal{ name: string; constructor(name: string) { this.name = name } run(distance: number = 10) { console.log(`${this.name}能跑 ${distance} m 远 `) } } class Cat implements Animal{ // 构造函数的另一种写法 constructor(public name: string) { } // 子类实现接口的方法,可以不传入参数 run() { console.log(`${this.name}能跑远 `) } // 定义自己的方法 eat(sth: string) { console.log(`${this.name}吃 ${sth}`) } } let dog = new Dog('田园犬') dog.run() let cat = new Cat('小橘') cat.run() cat.eat('鱼') 一个类也可以实现多个接口 interface Person{ name: string work(something: string ):void } interface Programmer{ coding(str: string):void } // 实现多个接口时用\",\"\" 隔开 class TS implements Programmer, Person{ constructor(public name: string) { } work(str: string) { console.log(`${this.name} 正在${str}`) } coding() { console.log(`${this.name} 正在撸代码`) } } let ts = new TS('panda') ts.work('学习') ts.coding() 四、接口的继承 就像类能继承一样, 接口也能继承, 这样能够实现多样功能. interface Person{ name: string work(something: string ):void } interface Programmer{ coding(str: string):void } // 接口也可以继承一个或多个接口, 多个接口用逗号分隔 interface FirstEnd extends Person, Programmer{ doSth(str: string): void } // 实现接口 class TS implements FirstEnd{ constructor(public name: string) { } work(str: string) { console.log(`${this.name} 正在${str}`) } coding() { console.log(`${this.name} 正在撸代码`) } doSth() { console.log('我是全干的程序员') } } let ts = new TS('panda') ts.work('学习') ts.coding() ts.doSth() 五、接口和类的混合使用 既然接口和类都能继承,那接口和类是能够混合使用的, 但是要主要继承以及实现的层级关系. interface Person{ name: string work(something: string ):void } interface Programmer{ coding(str: string):void } // 接口也可以继承一个或多个接口, 多个接口用逗号分隔 interface FirstEnd extends Person, Programmer{ doSth(str: string): void } // 定义类 class BackEnd{ constructor(name: string) { } writer() { console.log('后端也能写页面') } } // 先继承基类后实现接口 class TS extends BackEnd implements FirstEnd{ constructor(public name: string) { super(name) } work(str: string) { console.log(`${this.name} 正在${str}`) } coding() { console.log(`${this.name} 正在撸代码`) } doSth() { console.log('我是全干的程序员') } // 重写父类的方法 writer() { console.log('我是划水的狗子') } } let ts = new TS('panda') ts.work('学习') ts.coding() ts.doSth() // 若子类实现父类方法优先调用子类实现的方法, 否则调用父类的方法 ts.writer() "},"generics.html":{"url":"generics.html","title":"第六章: 泛型","keywords":"","body":"泛型 软件工程中,我们不仅要创建一致的定义良好的API,同时也要考虑重用性.组件不仅能支持当前的数据类型,同时也能支持未来的数据类型,这在创建大型系统时十分灵活.在Java中国可以使用泛型来创建可重用的组件, 一个组件可以支持多种类型数据.用户可以以自己的数据类型来使用组件. 泛型就是解决类、 接口、 方法的复用性、 以及对不特定数据类型的支持. 通俗理解指,在定义函数、接口或类的时候,不预先制定具体的类型,而在使用的时候再指定具体类型. 一、引入范型及使用 1. 引入范型 我们现在有这样需求, 创建一个函数,它返回任何传入的值.若不用泛型,我们可能使用联合类型,例如: function returnValue(arg: number | string | boolean ): any{ return arg } 这样是非常麻烦,或者我们也可以使用any, 但是会失去类型检查, 我们传入的和返回的可以类型不一致. function returnValue(arg: any ): any{ return arg } 因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的.这里，我们使用了 类型变量，它是一种特殊的变量，只用于表示类型而不是值。 我们把returnValue函数叫做泛型. 不同于使用 any，它不会丢失信息,保证传入类型和返回类型一致. 泛型:不预先确定的数据类型,具体的类型在使用的时候才确定 /* * T 代表Type.在定义泛型时通常⽤作第⼀个类型变量名称 * K 代表Key, 表示对象中国的键类型. * V 代表Value 表示对象中的值类型 * E 代表Element 表示元素类型 */ function returnValue(arg: T):T{ return arg } 2.使用泛型函数 定义泛型函数后有2种使用方法: 第一种: 传入所有的参数，包含类型参数.此方法使用麻烦. function returnValue(arg: T):T{ return arg } // 第一种,传入所有的参数,包括类型参数 let v = returnValue(\"panda\") 第二种:利用了类型推论 -- 即编译器会根据传入的参数自动地帮助我们确定T的类型. function returnValue(arg: T):T{ return arg } let v = returnValue('panda') console.log(v) 二、泛型接口 在定义接口时,为接口中的属性或者方法定义泛型类型,在是一个接口时,再指定具体的类型. interface Log { // 泛型类型的函数 (arg:T):T } // 泛型函数 function getLog(arg: T): T{ return arg } let myLog: Log = getLog; console.log(myLog(20)) // 20, 正确 console.log(myLog('panda')) // 正确, panda 还有另外一种方式, 就是我们想清楚的知道使用的泛型类型, 我们就要把泛型参数作为整个接口的一个参数, 这样接口里的其他成员也能知道这个参数的类型. interface Log { (arg: T): T; } // 泛型函数 function getLog(arg: T): T{ return arg; } // 使用时必须传入一个泛型类型,否则出错. let myLog: Log = getLog; // console.log(myLog(20)) // 错误, 类型不一致, console.log(myLog('panda')) // 正确 三、泛型类 在定义类时, 为类中的属性或方法定义泛型类型 在创建类的实例时, 再指定特定的泛型类型. 和泛型接口一样, 直接把泛型类型放在类后面,可以让我们知道类所有属性都是用相同类型. class GetValue{ constructor(tel: T) {} // 静态成员不能使用泛型类型 // static add(x: T) { } public list: T[] = []; run(x: T, y: T){ return x }; } let v = new GetValue('13212345678') v.run('12', '123') 四、泛型约束 泛型约束作用:望限制每个类型变量接受的类型数量 interface Inter{ length: number } // T extends Inter 表示使用接口给泛型添加约束 function interFn(value: T): T{ console.log(value, value.length) return value } console.log(interFn('123')) // console.log(interFn(123))// error number 类型没有length的属性 在泛型约束中使用类型参数 泛型约束的另⼀个常⻅的使⽤场景就是检查对象上的键是否存在. 可以使用keyof 来先获取某类型的所有键,keyof返回的是联合类型.然后再结合extends 约束,来限制输入的属性名包含在keyof返回的联合类型中. // 使用K extends keyof T 获取T的所有属性. // 再使用K判定要查找的属性是否存在 // 函数的返回值是key所对应的值 function getProperty(obj: T, key: K): T[K]{ return obj[key] } let x = { a: 1, b: 2, c: 3, d: 4 } console.log(getProperty(x,'a')) // 1 console.log(getProperty(x,'e'))// error 'e'不在x的属性中 五、泛型默认类型 当使⽤泛型时没有在代码中直接指定类型参数，从实际值参数中也⽆法推断出类型时，这个默认类型就会起作⽤. 泛型参数默认类型与普通函数默认值类似 // T=string,泛型默认类型为string interface A { name: T; } const strA: A = { name: \"panda\" }; // 不使用默认类型 const numB: A = { name: 101 }; 六、在泛型里使用类类型 在泛型里使用类类型,就是定义一个类, 把类做为参数来约束数据传入的类型. 现在我们有下面需求:定义User类和ArticleCate类映射数据库字段, 定义DBOper类操作数据库,然后把User类和ArticleCate类作为参数传入到DBOper中. class DBOper{ // 定义泛型方法,增加数据 add(info:T):boolean{ console.log(info); return true; } // 更新数据 updated(info:T,id:number):boolean { console.log(info); console.log(id); return true; } } // 定义User class User{ username:string | undefined; password:string | undefined; } class ArticleCate{ title:string | undefined; desc:string | undefined; status:number | undefined; constructor(params:{ title:string | undefined, desc:string | undefined, status?:number | undefined }){ this.title=params.title; this.desc=params.desc; this.status=params.status; } } let u = new User() u.username='panda' u.password = '123456' // 若不使用User类就可以传入任意类型, 然后都可以使用类中方法 var db = new DBOper(); db.add(u) var a=new ArticleCate({ title:'分类', desc:'1111', status:1 }); // 把ArticleCate作为参数传入. var Db = new DBOper() Db.add(a) Db.updated(a, 12) "},"namespace.html":{"url":"namespace.html","title":"第七章: 模块和命名空间","keywords":"","body":"模块和命名空间 一、模块 模块是在自己范围内执行,不再全局范围内执行, 这样模块中声明的变量、函数、类等在模块外不可见. 要想使用模块内的变量、函数、类等必须先在模块中使用export 关键字导出,然后在使用import关键字导入才能使用. 模块是自声明的, 两个模块之间的关系是通过在文件级别上使用imports和exports建立的. 1. 导出和导入 导出使用export关键字, 导入使用import关键字. // db.ts interface DBI{ add(info:T):boolean; update(info:T,id:number):boolean; delete(id:number):boolean; get(id:number):any[]; } // 第一种导出方式 // export class MysqlDb implements DBI{ class MySqlDb implements DBI{ constructor(){ console.log('数据库建立连接'); } // 增加数据 add(info: T): boolean { console.log(info); return true; } // 更新数据 update(info: T, id: number): boolean { console.log('更新数据') throw new Error(\"方法没实现\"); } // 删除数据 delete(id: number): boolean { console.log('删除数据') return true } // 获取数据 get(id: number): any[] { var list=[ { title:'xxxx', desc:'xxxxxxxxxx' }, { title:'xxxx', desc:'xxxxxxxxxx' } ] return list; } } // 第二种导出方式 export { MySqlDb }; 导入 // user.ts // 导入 import {MsSqlDb} from '../modules/db'; //定义数据库的映射 class UserClass{ username:string | undefined; password:string | undefined; } // 类作为泛型类的参数 var UserModel = new MySqlDb(); // 导出 export { UserClass, UserModel } 使用 // index.ts import {UserClass,UserModel} from './model/user'; //增加数据 var u=new UserClass(); u.username='张三'; u.password='12345655654757'; UserModel.add(u); //获取user表数据 var res=UserModel.get(123); console.log(res); 2. 默认导出 默认导出使用 default关键字标记；并且一个模块只能够有一个default导出.标记为默认导出的类和函数或变量的名字,在使用时可以省略. // b.ts export default function getUser(): any[]{ console.log('获取用户数据') return [ { \"id\": 1, \"name\": \"张三\" }, {\"id\":2, \"name\":\"法外之徒\"} ] } 使用 // index.ts import getUser from '../modules/b' console.log(getUser()) // 和上面效果一样,使用默认导出的类或函数或变量可以换成其它的 /* *import a from '../modules/b' *console.log(a()) */ 二、命名空间 在代码量较大的情况下，为了避免各种变量命名相冲突，可将相似功能的函数、类、接口等放置到命名空间内. 在TypeScript中, 命明空间就是之前的“内部模块”.TypeScript的命名空间可以将代码包裹起来，只对外暴露需要在外部访问的对象。命名空间内的对象通过export关键字对外暴露.只能访问通过export 暴露的变量、函数、类等, 否则错误. namespace X{ interface Animal{ name: string; run(): void; } export class Dog implements Animal { name: string; constructor(theName: string) { this.name = theName } run() { console.log(`${this.name}在跑`) } } } namespace X{ interface Animal{ name: string; run(): void; } export class Cat implements Animal { name: string; constructor(theName: string) { this.name = theName } run() { console.log(`${this.name}在跑`) } } } let dog = new X.Dog('田园犬') dog.run() let cat = new X.Cat('小橘') cat.run() 分离到多个文件 可以把命名空间的定义以及实现部分拆分为一个文件, 而使用在其他文件, 只需要导入使用的命名空间就行. // modules/b.ts // 注意: 此处要暴露整个命名空间 export namespace X{ interface Animal{ name: string; run(): void; } export class Cat implements Animal { name: string; constructor(theName: string) { this.name = theName } run() { console.log(`${this.name}在跑`) } } export class Dog implements Animal { name: string; constructor(theName: string) { this.name = theName } run() { console.log(`${this.name}在跑`) } } } 然后可以在使用的地方进行导入 // index.ts import { X } from \"../modules/b\"; let dog = new X.Dog('田园犬') dog.run() let cat = new X.Cat('小橘') cat.run() "},"decorators.html":{"url":"decorators.html","title":"第八章:装饰器","keywords":"","body":"装饰器 一、简介 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲,装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能. 更简单的理解可以认为就是在不修改源代码基础上能给源代码添加额外功能. 要想使用装饰器,必须在同时config.json里面启用experimentalDecorators编译器选项. { \"compilerOptions\": { \"target\": \"es2015\", // 启用装饰器 \"experimentalDecorators\": true } } 根据装饰器位置分类: 类装饰器、访问器装饰器、属性装饰器、方法装饰器、参数装饰器，但是没有函数装饰器。 根据装饰器是否有参数: 普通装饰器（无法传参） 、 装饰器工厂（可传参） 二、定义及使用 装饰器本质是一个函数,理论上忽略参数的话,任何函数都可以做装饰器使用.先定义一个函数，然后这个函数有一个参数，target就是要装饰的目标,定义了这个函数之后，它就可以作为装饰器，使用@函数名的形式，写在要装饰的内容前面. function helloWorld(target:any) { // 输出Function HelloWorldClass(){} 是当前装饰的类 console.log(typeof target, target) } // 使用装饰器 @helloWorld class HelloWorldClass{ } var hello = new HelloWorldClass() console.log(hello) 三、传参和不传参装饰器 1. 不传参装饰器(普通装饰器) 不传参装饰器就是不能传递参数, 但是可以动态扩展属性或者方法. function helloWorld(target:any) { // 输出Function HelloWorldClass(){} 是当前装饰的类 console.log(typeof target, target) // 动态扩展对象属性 target.prototype.name = 'panda'; // 动态扩展对象方法 target.prototype.say = function (): any{ console.log('我是划水的狗子') } } // 使用装饰器 @helloWorld class Person{ name: string; age?: number; constructor(n: string) { this.name = n } } var p:any = new Person(\"法外之徒\"); console.log(p.name); // 法外之徒 p.say(); // 我是划水的狗子 修饰器对类的行为的改变，是代码编译时发生的(不是TypeScript编译，而是js在执行机中编译阶段),而不是运行时.这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。 但是在是场景中,大多时间我们希望向装饰器传入一些参数, 所以要借助JavaScript中函数柯里化特性.这样就能实现在装饰器传参. 2. 传参数装饰器 装饰器传入参数我们发现可以打印出类的名字,target就是类的名字; params是我们传入的参数,同时我们可以通过prototypek可以重载类中的方法. function decoratorsClass(params: string) { return function (target: any) { // 传入的参数 console.log(params); console.log('----') // 被装饰的类 console.log(target); // 构造函数 console.log(target.prototype.constructor) target.prototype.say = function (): void{ // 使用传入的参数 console.log(params) } } } @decoratorsClass('张三这个法外之徒终于伏法') class Person{ say(){} } let p = new Person(); p.say() // 张三这个法外之徒终于伏法 四、常用装饰器 1. 类装饰器 从上面例子看出, 若类的装饰器返回一个值, 就会使用这个返回的值替换被装饰类的声明,所以可以使用此特性修改类的实现,可以通过装饰器，来覆盖类里一些操作. function desc(target:any) { return class extends target{ gender = '男'; name = 'padna'; age = 10 say() { console.log('我是重载过的'); } getData(){ console.log('获取数据') } } } @desc class Person { public name: string ; public age: number; constructor(name: string, age:number) { this.name = name; this.age = age; } // 会被覆盖 say() { console.log('能说会道!') } } let p:any = new Person('哈哈', 20); console.log(p.name, p.age, p.gender); p.say() // 我是重载过的 p.getData() 上面例子,首先定义了一个装饰器，它返回一个类，这个类继承要修饰的类，所以最后创建的实例不仅包含原 Person类中定义的实例属性，还包含装饰器中定义的实例属性;在装饰器里给实例添加属性，设置的属性值会覆盖被修饰的类里定义的实例属性,所以创建实例的时候虽然传入了字符串,但name的值还是panda. 2. 属性装饰器 属性装饰器会在运行时当作函数被调用,会传入下面2个参数: target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 propertyKey: 属性名字 属性装饰器没法操作属性的属性描述符，它只能用来判断某各类中是否声明了某个名字的属性。 function value(v: string) { return function (target: any, attr: string) { console.log(typeof attr, attr) target[attr] = v } } class Person{ @value('panda') public name: string | undefined; getName() { console.log(this.name) } } let person = new Person() person.getName() 3. 方法装饰器 方法装饰器用来处理类中方法，它可以处理方法的属性描述符，可以处理方法定义。方法装饰器在运行时也是被当做函数调用，含 3 个参数： Target: 装饰静态成员时是类的构造函数，装饰实例成员时是类的原型对象； propertyKey: 方法的名字； descriptor: 方法的属性描述符。 方法装饰器可以没有返回值, 若有返回值会被当做方法的属性描述符的对象. 无返回值 注意:若代码输出目标版本小于ES5，属性描述符将会是undefined function get(target: any, propertyKey: string, desc: any) { console.log(target) console.log(\"被装饰的方法\", propertyKey) console.log(desc) console.log(desc.value) // 扩展属性 target.prototype.method = 'Get' } class HttpClient{ @get getData() { console.log('获取数据成功') } } var http = new HttpClient() http.getData() 上面案例我们发现,desc.value 输出的是函数名, desc 输出的是writable(可读的), enumerable(可以枚举的), configurable(可配置的)和value 这些属性. 我们当然也可以在方法装饰器中扩展类的属性或方法. 有返回值 有返回值会被当做被装饰方法的属性描述符的对象,代码输出目标版本小于ES5，装饰器的返回值会被忽略 function desc(params: any) { return function (target: any, key: any, descriptor:any) { // 修改被装饰的函数的 let method = descriptor.value; // 修改被装饰方法的功能 descriptor.value = function (...args: Array) { // 把参数转换成字符串类型 args = args.map(it => String(it)); console.log(args); } } } class Person { public name: string | undefined; public age: number | 0; constructor(name, age) { this.name = name; this.age = age; } @desc('装饰器上的参数') say(...args:any[]) { console.log('说的方法') } } let p = new Person('哈哈', 20); console.log(p); p.say('ha') // ['ha] p.say('张三', 20, [20,30]) // ['张三','20',\"20,30\"] 四、方法参数装饰器 参数装饰器声明在一个参数声明之前（紧靠着参数声明).参数装饰器应用于类构造函数或方法声明, 参数装饰器不能用在声明文件、重载或其它外部上下文（比如 declare的类）里。 用来修饰方法中的参数.参数装饰器需要三个参数: Target: 当前对象的原型. propertyKey: 参数的名字 index: 参数数组中的位置 参数装饰器特殊之处可以提供信息，给比如给类原型添加了一个新的属性，属性中包含一系列信息，这些信息就被成为「元数据」，然后就可以使用另外一个装饰器来读取「元数据」. function desc(params: string) { return function (target: any, methodName:any, index:any) { console.log(target); // 类的原型 console.log(methodName); // 被装饰的名字 console.log(index); // 序列化 // 原型添加元数据 target.message = params } } class Person { public name: string | undefined; public age: number | 0; constructor(name, age) { this.name = name; this.age = age; } say(@desc('参数装饰器') age: number) { console.log('说的方法') } } let p:any = new Person('panda', 20); console.log(p); p.say(20); console.log(p.message) 五、访问器装饰器 访问器装饰器声明在一个访问器的声明之前。 访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。 注意:TypeScript不允许同时装饰一个成员的get和set访问器.取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的 访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数： Target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 propertyKey:成员的名字。 Descriptor: 成员的属性描述符。 function desc(params: boolean) { return function (target: any, propertyKey:any, descriptor:any) { console.log(target); // 类的原型 console.log(propertyKey); // 被装饰的名字 console.log(descriptor); // 序列化 // 修改描述符的对象值 descriptor.enumerable = params } } class Person { public _name: string | undefined; public _age: number | 0; constructor(name, age) { this._name = name; this._age = age; } // 设置为true,该属性才能出现在对象的枚举属性中 @desc(true) get name() { return this._name } // @desc(false) //error 不能向同名的存储器使用多个装饰器 set name(name: string) { this._name = name } // 设置为false,枚举属性会少一个 @desc(false) get age() { return this._age; } set age(age:number) { this._age = age } } let p = new Person('panda', 20); console.log(p.name) console.log(p.name = 'king') for (let prop in p) { console.log(`property = ${prop}`); } 五、常用装饰器的执行顺序 类中不同声明上的装饰器将按以下规定的顺序应用： 属性装饰>函数参数装饰器> 函数装饰器>类装饰器 function decCls(params: string) { return function (target: any) { console.log('4.类的装饰器'); } } function decMethod(params: string) { return function (target: any, key: string, descriptor: {[propsName: string]: any}) { console.log('3.类的函数装饰器'); } } function decParams(params: string) { return function (target: any, name: string) { console.log('1.类属性装饰器'); } } function decQuery(params: string) { return function (target: any, key: string, index: number) { console.log('2.函数参数装饰器'); } } @decCls('类的装饰器') class Person{ @decParams('属性装饰器') public name: string | undefined; @decMethod('函数装饰器') getData(@decQuery('函数参数装饰器') age: number, @decQuery('函数参数装饰器') gender: string) { console.log('----'); } } "}}